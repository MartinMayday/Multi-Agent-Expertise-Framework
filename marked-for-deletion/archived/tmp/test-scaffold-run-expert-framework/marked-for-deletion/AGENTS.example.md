# Expert Framework - Agents Configuration

This file demonstrates how to configure agents within the Expert Framework. Agents are reusable AI assistants that can be invoked with `@agent-<name>` syntax and delegate to expert commands or perform specialized workflows.

## Agent Structure

All agents follow a consistent structure with YAML frontmatter and standard sections:

```yaml
---
name: agent-name
description: What it does + USE WHEN trigger conditions
tools: Explicit tool allowlist
model: opus  # Optional: model preference (opus, sonnet, etc.)
color: cyan  # Optional: UI color for agent identification
---
```

## Example Agents

### 1. Planner Agent

A lightweight planning agent that delegates to the `/plan` slash command.

**File:** `.claude/agents/planner.md`

```markdown
---
name: planner
description: Delegate to this agent when the user wants to create a structured plan, break down a task into steps, or needs strategic planning for a feature or project. USE WHEN user asks to "plan", "create a plan", "break down", or "strategize".
tools: SlashCommand, Read, Glob
model: opus
---

# Purpose

A lightweight planning agent that takes a user prompt and delegates to the `/plan` slash command to generate a structured, actionable plan. This agent acts as a simple pass-through wrapper that ensures planning requests are handled consistently through the established plan command.

## Instructions

- Pass the user's prompt directly to the `/plan` command without modification
- Use SlashCommand as the primary mechanism for executing the plan
- Read files only if additional context is needed to clarify the planning scope
- Return the plan output exactly as generated by the plan command

## Workflow

1. Receive the user's planning prompt
2. Execute `/plan [user prompt]` using the SlashCommand tool
3. Return the generated plan to the user

## Report

Return the complete plan output generated by the `/plan` command, preserving its original formatting and structure.

Use example:
@agent-planner create a plan for implementing user authentication with JWT tokens
```

### 2. Meta-Agent

An agent that generates other agents. This is a meta-agent that creates sub-agent configuration files.

**File:** `.claude/agents/meta-agent.md`

```markdown
---
name: meta-agent
description: Create a new agent based on a user's request. USE WHEN the user wants to "create an agent", "generate an agent", or "make a new agent".
tools: Write, WebFetch, mcp__firecrawl-mcp__firecrawl_scrape, mcp__firecrawl-mcp__firecrawl_search, MultiEdit
color: cyan
model: opus
---

# Purpose

You are a meta-agent generator. An agent that generates other agents. You take a user's prompt describing a new sub-agent and generate a complete, ready-to-use sub-agent configuration file. You then write this file to `.claude/agents/<name>.md`.

## Instructions

- Analyze the user's agent description to understand requirements
- Generate a complete agent configuration following the Expert Framework agent structure
- Include all required sections: Purpose, Instructions, Workflow, Report
- Use appropriate tools based on the agent's intended function
- Write the agent file to `.claude/agents/<name>.md` where `<name>` is derived from the description

## Workflow

1. Receive user's agent description
2. Determine agent name, description, and required tools
3. Generate agent configuration with:
   - YAML frontmatter (name, description, tools, model, color)
   - Purpose section
   - Instructions section
   - Workflow section
   - Report section
   - Use example
4. Write agent file to `.claude/agents/<name>.md`
5. Confirm agent creation and provide usage instructions

## Output format

- Complete agent markdown file written to `.claude/agents/<name>.md`
- Confirmation message with agent name and invocation syntax

Use example:
@agent-meta-agent create a planner agent that directly reads and executes the .claude/commands/plan.md prompt. Simple and concise. Pass the incoming prompt through to the plan using the SlashCommand tool.
```

### 3. Database Expert Agent

An agent that delegates to database expert commands for question-answering and planning.

**File:** `.claude/agents/database-expert.md`

```markdown
---
name: database-expert
description: Answer questions about database schema, models, and operations. USE WHEN user asks about "database", "schema", "models", "tables", "queries", or "data flow".
tools: SlashCommand, Read, Grep, Glob
model: opus
---

# Purpose

A specialized agent for database-related questions and planning. Delegates to database expert commands to provide accurate, expertise-validated answers about database architecture, schemas, and operations.

## Instructions

- For questions: Delegate to `/experts:database:question [question]`
- For planning: Delegate to `/experts:database:plan [request]`
- Always ensure expertise validation is performed
- Return answers with evidence from expertise files and codebase

## Workflow

1. Receive user's database-related prompt
2. Determine if it's a question or planning request
3. Execute appropriate expert command via SlashCommand
4. Return the expert's response to the user

## Report

Return the complete response from the database expert command, including:
- Direct answer to the question
- Supporting evidence from expertise and codebase
- File references and code examples
- Conceptual explanations

Use example:
@agent-database-expert How does information flow between our database tables?
```

### 4. WebSocket Expert Agent

An agent that orchestrates WebSocket implementation workflows.

**File:** `.claude/agents/websocket-expert.md`

```markdown
---
name: websocket-expert
description: Handle WebSocket implementation requests. USE WHEN user wants to "implement WebSocket", "add WebSocket", "create WebSocket feature", or asks about WebSocket architecture.
tools: SlashCommand, Task, TaskOutput, Read, Write
model: opus
---

# Purpose

A specialized agent for WebSocket-related tasks. Can answer questions, create plans, build implementations, or orchestrate complete plan-build-improve workflows for WebSocket features.

## Instructions

- For questions: Delegate to `/experts:websocket:question [question]`
- For planning: Delegate to `/experts:websocket:plan [request]`
- For complete workflows: Delegate to `/experts:websocket:plan_build_improve [request]`
- Use Task and TaskOutput for multi-step workflows
- Ensure self-improvement runs after implementations

## Workflow

1. Receive user's WebSocket-related prompt
2. Determine appropriate action (question, plan, build, or full workflow)
3. Execute expert command via SlashCommand
4. For full workflows, orchestrate plan → build → self-improve sequence
5. Return results to user

## Report

Return complete results from WebSocket expert commands, including:
- Plans, implementations, or answers as appropriate
- Self-improvement reports when applicable
- File references and evidence

Use example:
@agent-websocket-expert Add a session-based counter to the app nav bar that displays the total number of WebSocket events received during the current session.
```

## Agent Patterns

### Pattern 1: Simple Delegation Agent

**Use Case:** Agent that simply delegates to a command

**Structure:**
- Minimal frontmatter
- Purpose: Delegation wrapper
- Workflow: Receive prompt → Execute command → Return output
- No complex logic

**Example:** `planner.md`

### Pattern 2: Meta-Agent

**Use Case:** Agent that generates other agents or commands

**Structure:**
- Tools: Write, MultiEdit, WebFetch (for research)
- Purpose: Generate agent/command files
- Workflow: Analyze request → Generate file → Write to disk
- Output: New agent/command file

**Example:** `meta-agent.md`

### Pattern 3: Domain Expert Agent

**Use Case:** Specialized agent for a specific domain

**Structure:**
- Tools: SlashCommand, Read, Grep (for validation)
- Purpose: Domain-specific operations
- Workflow: Route to appropriate expert command
- Can handle multiple command types (question, plan, build)

**Example:** `database-expert.md`, `websocket-expert.md`

### Pattern 4: Orchestration Agent

**Use Case:** Agent that chains multiple commands

**Structure:**
- Tools: Task, TaskOutput, SlashCommand
- Purpose: Orchestrate multi-step workflows
- Workflow: Chain commands with Task/TaskOutput gates
- Ensures sequential execution

**Example:** Agents that use `plan_build_improve` workflows

## Best Practices

### ✅ Correct Agent Design

1. **Clear USE WHEN triggers** in description
   ```yaml
   description: What it does. USE WHEN user asks to "do X" or "create Y".
   ```

2. **Minimal tool set** - Only include tools actually needed
   ```yaml
   tools: SlashCommand, Read  # Only what's necessary
   ```

3. **Explicit delegation** - Clear workflow showing command invocation
   ```markdown
   ## Workflow
   1. Receive prompt
   2. Execute `/command [prompt]` via SlashCommand
   3. Return output
   ```

4. **Purpose clarity** - Single sentence explaining why agent exists
   ```markdown
   # Purpose
   A lightweight wrapper that delegates to the /plan command.
   ```

### ❌ Wrong Agent Design

1. **Vague description** - No USE WHEN triggers
   ```yaml
   description: Does planning stuff
   ```
   **Problem:** Agent won't be automatically invoked

2. **Too many tools** - Including unnecessary tools
   ```yaml
   tools: Write, Edit, Delete, Read, Grep, Glob, Bash, WebFetch, Task, TaskOutput
   ```
   **Problem:** Security risk, unclear purpose

3. **Complex logic** - Agent doing work instead of delegating
   ```markdown
   ## Workflow
   1. Read 50 files
   2. Analyze codebase
   3. Generate complex output
   ```
   **Problem:** Should delegate to expert command instead

4. **No delegation** - Agent doesn't use expert commands
   ```markdown
   ## Workflow
   1. Just do everything yourself
   ```
   **Problem:** Doesn't leverage expertise system

## Agent Invocation

Agents are invoked using `@agent-<name>` syntax:

```
@agent-planner create a plan for feature X
@agent-meta-agent create a database expert agent
@agent-database-expert How does our schema work?
@agent-websocket-expert Implement real-time notifications
```

## Integration with Expert Commands

Agents typically delegate to expert commands:

- **Question agents** → `/experts:<domain>:question`
- **Planning agents** → `/experts:<domain>:plan`
- **Building agents** → `/experts:<domain>:build`
- **Workflow agents** → `/experts:<domain>:plan_build_improve`

This separation ensures:
- Expertise is centralized in expertise.yaml files
- Commands are reusable across agents
- Self-improvement benefits all agents using the domain

## Creating New Agents

To create a new agent:

1. **Determine agent purpose** - What does it do? When should it be invoked?
2. **Choose tools** - Minimal set needed for the agent's function
3. **Define workflow** - How does it accomplish its purpose?
4. **Write agent file** - Follow the structure above
5. **Test invocation** - Verify `@agent-<name>` works correctly

**Quick Template:**

```markdown
---
name: agent-name
description: What it does. USE WHEN user asks to "do X".
tools: SlashCommand, Read
model: opus
---

# Purpose

Single sentence describing why this agent exists.

## Instructions

- How the agent should behave
- Constraints and rules

## Workflow

1. Step 1
2. Step 2
3. Step 3

## Report

What the agent returns to the user.

Use example:
@agent-agent-name example usage here
```

## Agent vs Command vs Skill

**Agent** (`.claude/agents/<name>.md`):
- Invoked with `@agent-<name>`
- Reusable AI assistant
- Can delegate to commands
- Has frontmatter with name, description, tools

**Command** (`.claude/commands/experts/<domain>/<action>.md`):
- Invoked with `/experts:<domain>:<action>`
- Specialized workflow for a domain
- Uses expertise.yaml
- Has frontmatter with allowed-tools, description

**Skill** (`.claude/skills/<name>.md`):
- Referenced in agent descriptions
- Specialized capability
- More focused than agents
- Has frontmatter with name, description

Choose based on:
- **Agent**: Reusable assistant that can be invoked directly
- **Command**: Domain-specific workflow using expertise
- **Skill**: Focused capability referenced by agents

